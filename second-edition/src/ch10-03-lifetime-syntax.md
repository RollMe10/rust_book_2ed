## Проверка ссылок с помощью Lifetimes

Когда мы говорили о ссылках в Главе 4, мы опустили весьма важную деталь:
каждая ссылка в Rust имеет *время жизни*, определяющее область действия, в
которой ссылка является действительной. В большинстве случаев времена жизни
выводятся неявно, однако иногда времена жизни ссылок могут неоднозначно
соотноситься между собой. В таких случаях нам необходимо явно указать времена
жизни, используя синтаксис шаблонных параметров времен жизни чтобы компилятор
убедился в том, что ссылка, которую мы используем, всегда действительна.

Да, это немного необычно и может отличаться от концепций, к которым вы привыкли
в других языках программирования. Как бы то ни было, времена жизни — наиболее
яркая отличительная черта языка Rust.

Эта тема настолько обширна, что в этой главе мы сможем изложить только синтаксис
и общие концепции. Глава 19 содержит больше подробной информации обо всех
возможностях времён жизни.

### Lifetimes защищают программу от недействительных ссылок

Главная цель существования времён жизни — это предотвращение использования
недействительных ссылок. Это весьма коварная ошибка, которую трудно заметить.
Для примера, давайте рассмотрим код (10-18). Здесь демонстрируется поведение
переменных в различных областях видимости. Во внешней области видимости мы
декларируем переменную `r` без её инициализации. Во внутренней области видимости
мы декларируем переменную `x` и инициализируем её значением `5`. Далее в этой же
области видимости мы пытаемся присвоить переменной `r` ссылку на переменную `x`.
Затем, когда внутренняя область видимости закончилась, мы хотим напечатать
содержимое переменной `r` во внешней области видимости:

```rust,ignore
fn main(){
    let r;

    {
        let x = 5;
        r = &x;
    }

    println!("r: {}", r);
}
```

<span class="caption">Пример 10-18: Попытка использования ссылки, значение
которой вышло из области видимости</span>

> #### Неинициализированные переменные не могут быть использованы
>
> Следующие несколько примеров демонстрируют объявление переменных без их
> инициализации таким образом, что имя переменной существует во внешней области
> видимости. Это может показаться странным, поскольку Rust не имеет
> null-значений. Однако, если мы попробуем использовать переменную без её
> инициализации — мы получим ошибку компиляции. Попробуйте сами!

Если мы попробуем скомпилировать этот код — мы получим следующую ошибку:

```text
error: `x` does not live long enough
   |
6  |         r = &x;
   |              - borrow occurs here
7  |     }
   |     ^ `x` dropped here while still borrowed
...
10 | }
   | - borrowed value needs to live until here
```

Переменная `x` живёт «недостаточно долго». Но почему? Всё дело в том, что `x`
выходит из области видимости когда мы закрываем фигурную скобку в строке 7. Но
`r` всё ещё доступна во внешней области видимости, которая больше внутренней.
Поэтому мы говорим, что `r` «живёт дольше». Если бы Rust позволил этому коду
работать, переменная `r` указывала бы на память, которая была освобождена когда
`x` вышла из области видимости. Любые действия с переменной `r` привели бы к
некорректной работе программы. Но как же Rust понимает что этот код —
неправильный?

#### Проверка заимствования

В состав компилятора Rust входит функциональность называющаяся
*проверка заимствования*, сравнивающая области видимости чтобы убедиться в
корректности всех ссылок. Демонстрационный код (10-19) иллюстрирует всё тот же
пример (10-18), графически изображая область действия имеющихся переменных:

```rust,ignore
{
    let r;         // -------+-- 'a
                   //        |
    {              //        |
        let x = 5; // -+-----+-- 'b
        r = &x;    //  |     |
    }              // -+     |
                   //        |
    println!("r: {}", r); // |
                   //        |
                   // -------+
}
```

<span class="caption">Пример 10-19: Описание времён жизни переменных `r` и
`x`, с помощью идентификаторов `'a` и `'b`</span>

<!-- Just checking I'm reading this right: the inside block is the b lifetime,
correct? I want to leave a note for production, make sure we can make that
clear -->
<!-- Yes, the inside block for the `'b` lifetime starts with the `let x = 5;`
line and ends with the first closing curly brace on the 7th line. Do you think
the text art comments work or should we make an SVG diagram that has nicer
looking arrows and labels? /Carol -->

Мы описываем время жизни переменной `r` с помощью `'a` и время жизни переменной
`x` с помощью описательной переменной `'b`. Обратите внимание, что блок `'b`
находится внутри блока `'a` и значительно меньше. Во время компиляции,
компилятор Rust сравнивает размеры времён жизни и видит, что переменная `r`
имеет время жизни `'a`, но ссылается на объект с временем жизни `'b`. Такая
программа не скомпилируется потому что время жизни `'b` короче, чем время жизни
`'a`. Ссылка, указывающая на данные живёт дольше, чем сами данные.

Рассмотрим другой пример (10-20), в котором нет проблем с недействительными
ссылками.

```rust
{
    let x = 5;            // -----+-- 'b
                          //      |
    let r = &x;           // --+--+-- 'a
                          //   |  |
    println!("r: {}", r); //   |  |
                          // --+  |
}                         // -----+
```

<span class="caption">Пример 10-20: Все ссылки действительны, поскольку данные
имеют большее время жизни, чем ссылка</span>

Здесь переменная `x` имеет время жизни `'b`, которое больше, чем время жизни
`'a`. Это означает, что переменная `r` может ссылаться на переменную `x` и её
значение будет действительно до конца блока, в котором была объявлена
переменная `x`.

После того, как мы на примерах рассмотрели времена жизни ссылок и обсудили как
Rust их анализирует, давайте поговорим об обобщенных временах жизни параметров
функций и возвращаемых значений.

### Обобщенные времена жизни в функциях

Напишем функцию, которая возвращает наибольшую по длине строку. Эта функция
должна получать два строковых среза в качестве параметров функции и возвращать
строковый срез в качестве результата. Код в примере 10-21 должен напечатать
`The longest string is abcd`.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
```

<span class="caption">Пример 10-21: Функция `main` вызывает функцию `longest`
для поиска наибольшей строки</span>

Обратите внимание, что мы хотим чтобы функция принимала в качестве параметров
срезы строк (которые являются ссылками, об этом мы говорили в Главе 4) потому
что мы не хотим чтобы функция `longest` принимала владение передаваемых
аргументов. Мы хотим, чтобы функция могла принимать в качестве аргументов срезы
от строк типа `String` и строковые литералы (переменная `string1` имеет тип
`String`, а `string2` — строковый литерал).

<!-- why is `a` a slice and `b` a literal? You mean "a" from the string "abcd"? -->
<!-- I've changed the variable names to remove ambiguity between the variable
name `a` and the "a" from the string "abcd". `string1` is not a slice, it's a
`String`, but we're going to pass a slice that refers to that `String` to the
`longest` function (`string1.as_str()` creates a slice that references the
`String` stored in `string1`). We chose to have `string2` be a literal since
the reader might have code with both `String`s and string literals, and the way
most readers first get into problems with lifetimes is involving string slices,
so we wanted to demonstrate the flexibility of taking string slices as
arguments but the issues you might run into because string slices are
references.
All of the `String`/string slice/string literal concepts here are covered
thoroughly in Chapter 4, which is why we put two back references here (above
and below). If these topics are confusing you in this context, I'd be
interested to know if rereading Chapter 4 clears up that confusion.
/Carol -->

Освежим в памяти материал Главы 4 (секцию «Срезы строк в качестве аргументов»)
для того, чтобы понять почему мы хотим использовать именно такие аргументы.

Если мы попробуем реализовать функцию `longest` так, как это показано в примере
кода 10-22, то программа не будет скомпилирована:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

<span class="caption">Пример 10-22: Реализация функции `longest`, которая
возвращает наибольший срез строки, но пока ещё не компилируется</span>

Вместо этого мы получим следующую ошибку, сообщающую о проблемах
в определении времени жизни возвращаемого параметра:

```text
error[E0106]: missing lifetime specifier
   |
1  | fn longest(x: &str, y: &str) -> &str {
   |                                 ^ expected lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the
   signature does not say whether it is borrowed from `x` or `y`
```

Справочный текст сообщает нам о том, что возвращаемому параметру нужно указать
параметр времени жизни, потому что Rust не может определить на какую переменную
ссылается возвращаемая ссылка, на `x` или `y`. На самом деле, даже мы не знаем
что вернёт тело этой функции: ссылку на `x` или `y`.

Мы определили функцию `longest` таким образом, что мы не знаем конкретных
значений, которые в неё передаются. Поэтому мы не знаем какая из ветвей
оператора `if` будет выполнена. Мы также не знаем конкретных времён жизни
ссылок, передаваемых в функцию, из-за чего не можем посмотреть на их области
видимости, как мы делали в примерах 10-19 и 10-20, чтобы убедиться что
возвращаемая ссылка всегда действительна. Компилятор тоже не может нам помочь
потому что он не знает как времена жизни переменных `x` и `y` соотносятся с
временем жизни возвращаемого значения. Мы собираемся добавить обобщённый
параметр времени жизни, который определит отношения между ссылками чтобы
компилятор мог провести анализ ссылок с помощью проверки заимствования.

### Синтаксис аннотаций времён жизни

Аннотации времён жизни не меняют продолжительность жизни ссылок. Функции могут
принимать ссылки с любым временем жизни если в сигнатуре указан обобщённый
параметр времени жизни по аналогии с тем, как функции принимают аргумент любого
типа если в сигнатуре функции указан обобщённый (generic) параметр. Что
аннотации времён жизни действительно делают — это определяют отношения множества
ссылок между собой.

Аннотация времени жизни имеет немного необычный синтаксис: имена параметров
времени жизни обязаны начинаться с апострофа `'`. Имена времён жизни обычно
очень короткие и пишутся в нижнем регистре. Обычно по умолчанию большинство
людей использует имя `'a`. Аннотации параметров функции временем жизни следуют
после символа `&` ссылочного типа данных и разделяются пробелом от названия типа
данных ссылки.

Приведём несколько примеров: у нас есть ссылка на `i32` без указания времени
жизни, ссылка на `i32`, с временем жизни, имеющим имя `'a` и изменяемая ссылка
на `i32`, которая тоже имеет время жизни `'a`.

```rust,ignore
&i32        // ссылка
&'a i32     // ссылка с явно указанным времени жизни
&'a mut i32 // изменяемая ссылка с явным временем жизни
```

Одна аннотация времени жизни сама по себе не имеет большого смысла, аннотации
времени жизни сообщают компилятору Rust как обобщённые параметры времени жизни
множества ссылок связаны между собой. Предположим что у нас есть функция с
параметром `first`, имеющим ссылочный тип данных `&i32` и время жизни `'a` и
вторым параметром `second`, который также имеет ссылочный тип `&i32` с временем
жизни `'a`. Аннотации времени жизни этих параметров имеют одинаковое имя. Это
показывает что ссылки `first` и `second` должны жить в программе одинаково
долго.

### Аннотации времён жизни в сигнатуре функции

Давайте посмотрим на аннотации времён жизни в контексте функции `longest`, над
которой мы работаем. Обобщённые параметры времени жизни объявляются в
треугольных скобках между именем функции и списком её параметров таким же
образом, как и обобщённые типы данных. Ограничение для ссылок в параметрах и
возвращаемом значении говорит о том, что все они имеют одинаковое время жизни
`'a`, добавленное к каждой ссылке как показано в примере 10-23.

<span class="filename">Файл: src/main.rs</span>

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

<span class="caption">Пример 10-23: В сигнатуре функции `longest` указано что
все ссылки должны иметь одинаковое время жизни — `'a`</span>

Теперь код (10-21), использующий эту функцию, может быть скомпилирован.

Компилятор теперь знает достаточно о функции `longest` чтобы убедиться в ссылочной
целостности.

Когда необходимо описание времени жизни функций, это описание может располагаться
только в заголовке функции. Это описание необходимо, как тонкая настройка целостности
данных.

Т.к. время жизни переменных может отличаться друг от друга, при использовании данной
функции берётся наименьшее значение. Только в этом случае мы можем гарантировать,
что возвращаемое значение будет иметь действительное время жизни.

Рассмотрим пример ограничений времени жизни работает на следующем примере (10-24):

<span class="filename">Файл: src/main.rs</span>

```rust
# fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
#     if x.len() > y.len() {
#         x
#     } else {
#         y
#     }
# }
#
fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {}", result);
    }
}
```

<span class="caption">Код программы 10-24: Использование функции `longest` и ссылок
на строковые данные `String`, которые имеют разное время жизни</span>

Далее рассмотрим пример, которые покажет, что время жизни результата работы
функции — минимальное из имеющихся. Мы переместим определение переменной `result`
из внутренней области видимости, но присвоим значение внутри внутренней области
видимости. При таких условиях, пример кода 10-25 не будет скомпилирован:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {}", result);
}
```

<span class="caption">Listing 10-25: Попытка использование переменной `result`
после выхода переменной `string2` за пределы области видимости</span>

Описание ошибки:

```text
error: `string2` does not live long enough
   |
6  |         result = longest(string1.as_str(), string2.as_str());
   |                                            ------- borrow occurs here
7  |     }
   |     ^ `string2` dropped here while still borrowed
8  |     println!("The longest string is {}", result);
9  | }
   | - borrowed value needs to live until here
```

Эта ошибка возникает из-за минимального значения времени жизни одного из значений
входных данных функции.

Пожалуйста, поэкспериментируйте со значениями времени жизни ссылок! Посмотрите,
какая из ссылок используется для определения времени жизни результата.

### Думай категориями времени жизни

Для того, чтобы точно определить время жизни параметров необходимо точно знать,
что будет делать функция. Например, если мы изменили реализацию функции `longest`
 в новой редакции функция будет всегда возвращать первый аргумент, то в этом случае
 нет необходимости устанавливать время жизни параметра `y`:

<span class="filename">Файл: src/main.rs</span>

```rust
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
```

Для того, чтобы не было сообщений компилятора о неиспользуемом параметре, сделайте,
как рекомендуется:

<span class="filename">Файл: src/main.rs</span>

```rust
fn longest<'a>(x: &'a str, _y: &str) -> &'a str {
    x
}
```

В этом примере мы сообщили параметр времени жизни `'a` для параметра `x` и возвращаемого
значения, но не для параметра `y`.

Если же в коде метода возвращаемая ссылка не будет ссылаться на какой-либо из аргументов,
тогда эта ссылка при выходе из области видимости станет недействительной, что приведёт
к ошибке компиляции и другим тревожным сообщениям:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.as_str()
}
```

Даже если будет установлен параметр время жизни у возвращаемого значения, этот код
также не будет скомпилирован, т.к. возвращаемое значение не будет связано с временем
жизни какого-либо из параметров.

Сообщение об ошибке:

```text
error: `result` does not live long enough
  |
3 |     result.as_str()
  |     ^^^^^^ does not live long enough
4 | }
  | - borrowed value only lives until here
  |
note: borrowed value must be valid for the lifetime 'a as defined on the block
at 1:44...
  |
1 | fn longest<'a>(x: &str, y: &str) -> &'a str {
  |                                             ^
```
Т.к. время жизни переменной истекает после выхода её из области видимости функции,
такой код не будет скомпилирован.

Как только будет установлена связь времени жизни входящих переменных и возвращаемого
значения - для компилятора будет достаточно информации, чтобы сделать проверки и
скомпилировать код, исключив возможность появления недействительных ссылок.

### Определение времени жизни при объявлении структур

До сих пор мы объявляли структуры, которые содержали нессылочные типы данных.
В структурах возможно использовать и ссылочные типы данных, но при этом необходимо
добавить описание времени жизни каждой ссылки в определение структуры. Пример кода
10-26 описывает структуру `ImportantExcerpt` содержащую срезы строковых данных:

<span class="filename">Файл: src/main.rs</span>

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.')
        .next()
        .expect("Could not find a '.'");
    let i = ImportantExcerpt { part: first_sentence };

    println!("{}",i.part);
}
```

<span class="caption">Пример кода 10-26: Структура, которая содержит ссылку и определение
времени жизни</span>

Обратите внимание, что поле структуры `ImportantExcerpt` содержит ссылку

Синтаксис такой же, как и при работе с обобщенными типами данных.

Функция `main` создаёт экземпляр структуры `ImportantExcerpt`, который содержит
ссылку на первое предложение из переменной `novel`.

### Правила неявного определения времени жизни

Подведём промежуточные итоги изучения описания времени жизни. Из этой части главы
мы узнали, что каждая ссылка имеет время жизни и нам нужно устанавливать параметры
времени жизни для функций или структур, которые используют ссылки.

Также, изучая материал Главы 4, мы создали функции (в секции “String Slices”), которая
использует ссылки, но при этом компилятор для её работы не требует информации
о времени жизни (Пример кода 10-27):

<span class="filename">Файл: src/lib.rs</span>

```rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

<span class="caption">Код программы 10-27: Обратите внимание, что функция, которую
мы определили в Главе 4 компилируется без описания времени жизни ссылок, несмотря на
то, что и входной параметр и выходной — ссылки</span>

Причина по которой это код может быть скомпилирован — историческая, первые версии
Rust предполагали явное указание подобной функциональности.
Чтобы использовать возможности компилятора по анализу вероятных ошибок, сейчас
мы рекомендуем написать данный код следующим образом:

```rust,ignore
fn first_word<'a>(s: &'a str) -> &'a str {
```

После продолжительной работы и накопления большого опыта, разработчики языка Rust
обнаружили, что описания времени жизни программисты пишут в определённых шаблонных
решениях и практиках. Программисты Rust решили сделать так, что в таких случаях
сам компилятор может расставлять переменные времени жизни без явного объявления его
в коде программы.

Поскольку язык Rust постоянно развивается, возможно, в будущем в него будет добавлено
ещё больше шаблонов для автоматического расставления аннотаций времени жизни.

Шаблоны, по которым компилятор Rust анализирует ссылки называются *правилами неявного
выведения времени жизни*. Эти правила существуют для компилятора, а не для пишущего
на Rust программиста. Знание этих правил позволит не описывать время
жизни ссылок там, где это делать необязательно.

Неявные правила не имеют четких ограничений. Эти правила выводятся на основе имеющихся
данных в коде программы. Если этих данных не будет достаточно — компилятор выведет
соответствующее сообщение и не скомпилирует код.

Сейчас мы рассмотрим правила анализа переменных времени жизни.
Первое правило применяется к входным переменным. Последующие два правила применяются
к выходным переменным. Если компилятор применил эти правила, и в результате этого
он не смог определить связывание данных переменных, компилятор остановит свою работу и
сообщит об ошибке. Вот эти правила:

1. Каждый параметр является ссылкой получающей свой собственный параметр времени жизни.
   Другими словами, функция с одним параметром получает один параметр времени жизни:
   `fn foo<'a>(x: &'a i32)`. Функция с двумя аргументами получает два различных
  параметра времени жизни: `fn foo<'a, 'b>(x: &'a i32, y: &'b i32)` и так далее.

2. Если существует один параметр времени жизни — он связывается со всеми выходными
   параметрами: `fn foo<'a>(x: &'a i32) -> &'a i32`.

3. Если есть множество входных параметров времени жизни и один из них является
   ссылкой `&self` или `&mut self` (т.к. это ссылка на метод структуры или
   перечисления — то в этом случае, параметр времени жизни `self` будет связан со всеми
   выходными параметрами времени жизни.

Вооружившись этими знаниями, вернёмся к функции `first_word` и рассмотрим подробнее
её заголовок. В нём нет описания времени жизни:

```rust,ignore
fn first_word(s: &str) -> &str {
```

Теперь применим первое правило, утверждающее, что каждый параметр получает свой
собственный параметр времени жизни. Пропишем это условие явным образом:

```rust,ignore
fn first_word<'a>(s: &'a str) -> &str {
```

Применяется второе правило, так как указан только один входной параметр времени
жизни. Следовательно, данная переменная времени жизни свяжется с выходной переменной
времени жизни. Перепишем заголовок функции с учётом этого правила:

```rust,ignore
fn first_word<'a>(s: &'a str) -> &'a str {
```

Теперь все ссылки в этой функции имеют параметры времени жизни и компилятор может
продолжить свой анализ без необходимости получать дополнительную информацию от
программиста.

Давайте рассмотрим ещё один пример: заголовок функции `longest`, в котором нет
параметров времени жизни из примера 10-22:

```rust,ignore
fn longest(x: &str, y: &str) -> &str {
```

Применим правила времени жизни:

```rust,ignore
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
```

Второе правило нельзя применить потому что указано больше одного входного параметра. Смотрим
третье правило. Оно также не применимо, так как `longest` — функция, а не метод. Поэтому
компилятор в данном случае сообщит об ошибке (Пример кода 10-22).

Мы знаем, что третье правило применяется только к методам, давайте рассмотрим работу этого
правила подробнее.

### Описание времени жизни в определении методов

<!-- Is this different to the reference lifetime annotations, or just a
finalized explanation? -->
<!-- This is about lifetimes on references in method signatures, which is where
the 3rd lifetime elision rule kicks in. It can also be confusing where lifetime
parameters need to be declared and used since the lifetime parameters could go
with the struct's fields or with references passed into or returned from
methods. /Carol -->

Когда мы реализуем методы в структурах с описанием времени жизни, синтаксис
описаний схож с аннотациями обобщенного программирования (Пример кода 10-11).
Место где описания времени жизни определяются и используются зависит от того
с чем он связывается — с полем структуры либо с аргументами методов и возвращаемыми
значениями.

Имена переменных времени жизни для полей структур всегда должны описываться после
ключевого слова `impl` и затем помещаться после имени структуры, так как имя —
неотъемлемая часть типа данных структуры.

В описании методов внутри блока `impl` ссылки могут быть связаны с ссылками полей
или могут быть независимыми. Дополнительно, правила неявного использования
времени жизни делают использование переменных времени жизни необязательными.
Рассмотрим пример кода. Используем структуру `ImportantExcerpt` из примера 10-26.

Здесь в методе `level` входной параметр — ссылка на `self` и возвращаемое
значение типа `i32` (не ссылка):

```rust
# struct ImportantExcerpt<'a> {
#     part: &'a str,
# }
#
impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
```

Описание параметра времени жизни находится после `impl` и используется после имени.
Нам не нужно добавлять информацию к входному параметру (правило 1).

Пример применения третьего правила:

```rust
# struct ImportantExcerpt<'a> {
#     part: &'a str,
# }
#
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
}
```

Тут два входных параметра. Применяем первое правило. Так как один из параметров — `&self`,
возвращаемое значение будет иметь время жизни переменой `&self`.

### Статическая переменная времени жизни

Существует ещё одно особенное время жизни — `'static`. Оно описывает всё время жизни
программы. Все строковые литералы имеют этот тип времени жизни, которое мы можем
указать явным образом:

```rust
let s: &'static str = "I have a static lifetime.";
```

Содержание этой строки сохраняется внутри бинарного кода вашей программы и всегда
доступно для использования. Поэтому время жизни всех строковых литералов — `'static`.

<!-- How would you add a static lifetime (below)? -->
<!-- Just like you'd specify any lifetime, see above where it shows `&'static str`. /Carol -->

Сообщения компилятора могут предлагать использовать `'static`. Прежде чем
использовать данный тип переменной времени жизни, пожалуйста, подумайте, должна ли
данная переменная быть доступна во время работы программы. Очень часто такие ссылки
являются источником скрытых ошибок.

### Обобщенные типы, связывание с типажом и переменные времени жизни

Теперь, когда мы узнали о синтаксисе переменных времени жизни, настала пора
объединить эти знания с другими концепциями языка Rust. Рассмотрим пример определения
обобщенных параметров, типажей и переменных времени жизни вместе:

```rust
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str
    where T: Display
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

Это видоизмененный пример функции `longest` (код программы 10-23). Программа
возвращает наибольшую строку. Обратите внимание на дополнительный аргумент обобщенного
типа `ann: T`! Он может быть любым, реализующим типаж `Display`. Содержание данной
переменной будет напечатано прежде, чем будет произведено сравнение строк. Так как переменные
времени жизни - это разновидность обобщенного типа параметров, они располагаются
вместе.

## Итоги

В этой главе мы рассмотрели много важного материала для понимания работы переменных
времени жизни. Вы уже знаете достаточно, чтобы писать программы и не дублировать
создаваемый вами код. Обобщенные параметры помогают использовать код для различных
типов данных. Типажи и связывания с типажами помогают соблюсти конвенции и контракты
чтобы иметь предсказуемое поведение. Также, у нас есть эффективный способ борьбы с
недействительными ссылками. Вся эта подготовительная работа проводится в момент
компиляции. Есть ещё темы, дополняющие эту картину. В Главе 17 вы изучите
типажные объекты (это ещё один способ использовать типажи). В Главе 19 будет говориться
о сложных сценариях использования переменных времени жизни. В Главе 20 будет рассмотрена
система опций. В следующей главе мы расскажем о том, как писать тесты в Rust.
